@using FSM
@inherits ModuleCheckBaseComponent
@implements IAsyncDisposable
@inject IFSMDrawer _fsmDrawer
@inject ILogger<FSMCanvas> _logger

<div class="center">
	Export as:
	<a href="javascript:saveAsPNG()"
	   download>PNG</a>
	   |
	<a href="javascript:saveAsSVG()"
	   download>SVG</a>
	   |
	<a href="javascript:saveAsLaTeX()"
	   download>LaTeX</a>
</div>

<canvas
	id="FSMCanvas"
	@ref="_canvasElement"
	contenteditable="true"
	height="@Height"
	width="@Width"
	@onmousedown:preventDefault
	@onmousedown="ClicksStateHandler"
	@onkeydown:preventDefault
	@onkeydown="KeyHandler"
	@onmousemove="MoveMouseHandler"
	@onblur="DeselectState"
>
	Your browser does not support the HTML5 &lt;canvas&gt;
	element.
</canvas>

@code {
	[Parameter]
	public int Height { get; set; } = 150;

	[Parameter]
	public int Width { get; set; } = 300;

	[Parameter]
	public bool MustRetryContext { get; set; } = false;

	private ElementReference? _canvasElement;

	private Timer? _drawTimer;
	private bool _canResizeState = false;
	private bool _stopTimer = true;
	private bool _caretVisible = true;
	private int _drawTimerInterval = 500;
	private DateTime _lastDrawTimerCall = DateTime.Now;

	/// <summary>
	/// The last X co-ordinate of pointer relative in the canvas space.
	/// </summary>
	private int _lastXPos;
	/// <summary>
	/// The last Y co-ordinate of pointer relative in the canvas space.
	/// </summary>
	private int _lastYPos;

	private float _defalutStateRadius = 30;
	private bool _canvasHasFocus = false;

	private const string _selectedStateColour = "#0000ff";
	private const string _stateColour = "#000000";

	private readonly string[] _specialSymbolNames = new string[] { 
		"Alpha",
		"Beta",
		"Gamma",
		"Delta",
		"Epsilon",
		"Zeta",
		"Eta",
		"Theta",
		"Iota",
		"Kappa",
		"Lambda",
		"Mu",
		"Nu",
		"Xi",
		"Omicron",
		"Pi",
		"Rho",
		"Sigma",
		"Tau",
		"Upsilon",
		"Phi",
		"Chi",
		"Psi",
		"Omega",
		"emptyset",
		"rightarrow",
		"leftarrow",
	};

	protected async override Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			_drawTimer = _drawTimer = new Timer(DrawMachineTimer, null, 0, _drawTimerInterval);

			await SetJsModule("./Components/FSMCanvas.razor.js");

			if (CheckJsModule(JsModule))
			{
				_fsmDrawer.SetStateColours(_stateColour, _selectedStateColour);
				_fsmDrawer.SetJsModule(JsModule);
				await JsModule.InvokeAsync<bool>("getCanvasContext", "FSMCanvas");
			}
		}
		if (CheckJsModule(JsModule) && MustRetryContext)
		{
			var isCreated = await JsModule.InvokeAsync<bool>("getCanvasContext", "FSMCanvas");

			if (isCreated)
				MustRetryContext = false;
			else
				_logger.LogError("Couldn't get 2d context");
		}

		if (_canvasElement != null && _canvasHasFocus)
		{
			await _canvasElement.Value.FocusAsync(true);
			_canvasHasFocus = false;
		}

		if (!_stopTimer && _fsmDrawer.SelectedState != null
			&& _drawTimer != null
			&& (DateTime.Now - _lastDrawTimerCall) > TimeSpan.FromMilliseconds(_drawTimerInterval * 1.1))
		{
			await _drawTimer.DisposeAsync();

			_drawTimer = new Timer(DrawMachineTimer, null, 0, _drawTimerInterval);
			_logger.LogDebug("Restarted the draw timer");
		}
	}

	private void SetLastCoords(double x, double y)
	{
		_lastXPos = (int)x;
		_lastYPos = (int)y;
	}

	private async Task ClicksStateHandler(MouseEventArgs mouseEventArgs)
	{
		SetLastCoords(mouseEventArgs.OffsetX, mouseEventArgs.OffsetY);

		if (CheckJsModule(JsModule))
		{
			var coordinate = new CanvasCoordinate(_lastXPos, _lastYPos);
			FiniteState? existingState = _fsmDrawer.FSM.FindState(coordinate);

			if (mouseEventArgs.Detail == 2)
			{
				if (existingState == null)
				{
					CanvasCoordinate? createdCoords = await _fsmDrawer.CreateState(
						_lastXPos,
						_lastYPos,
						_defalutStateRadius,
						_selectedStateColour
					);
					_stopTimer = !(createdCoords != null);
					if (_stopTimer)
						_logger.LogError("State to be created at {Coordinate} failed to be created", createdCoords);

					return;
				}
				else if (existingState != null && existingState == _fsmDrawer.SelectedState)
					_fsmDrawer.SelectedState.IsFinalState = !_fsmDrawer.SelectedState.IsFinalState;
			}

			FiniteState? prevSelectedState = _fsmDrawer.SelectedState;
			_fsmDrawer.SelectedState = existingState;

			if (prevSelectedState != _fsmDrawer.SelectedState)
			{
				switch (_fsmDrawer.SelectedState)
				{
					case null:
						_stopTimer = true;
						await _fsmDrawer.DrawMachineAsync();
						break;
					default:

						_stopTimer = false;
						_caretVisible = true;
						await _fsmDrawer.DrawMachineAsync(_caretVisible);
						break;
				}
			}

			if (_fsmDrawer.SelectedState != null)
			{
				var coords = _fsmDrawer.SelectedState.Coordinate;
				float radius = (float)Math.Sqrt(
					Math.Pow(mouseEventArgs.OffsetX - coords.X, 2)
					+ Math.Pow(mouseEventArgs.OffsetY - coords.Y, 2)
				);

				_logger.LogInformation("Radius difference: {Difference}", Math.Abs(radius - _fsmDrawer.SelectedState.Radius));
				if (Math.Abs(radius - _fsmDrawer.SelectedState.Radius) <= 10)
					_canResizeState = true;
				else
					_canResizeState = false;
			}
		}
		if (_canvasElement != null)
			_canvasHasFocus = true;
	}

	private async Task KeyHandler(KeyboardEventArgs keyboardEventArgs)
	{
		if (CheckJsModule(JsModule) && _fsmDrawer.SelectedState != null)
		{
			switch (keyboardEventArgs.Key.ToLower())
			{
				case "backspace":
					if (_fsmDrawer.SelectedState.Text.Length > 0)
					{
						var text = _fsmDrawer.SelectedState.Text;
						_fsmDrawer.SelectedState.Text = text.Substring(0, text.Length-1);
						var coordinate = _fsmDrawer.SelectedState.Coordinate;

						_caretVisible = true;
					}
					break;
				case "delete":
					_fsmDrawer.FSM.RemoveState(_fsmDrawer.SelectedState);
					break;
				case "return":
				case "enter":
				case "↵":
					_fsmDrawer.SelectedState.Text += '\n';
					_caretVisible = true;
					break;
				case "spacebar":
				case " ":
					_fsmDrawer.SelectedState.Text += ' ';
					_caretVisible = true;
					break;
				default:
					bool hasNoSpecialKeys = !keyboardEventArgs.MetaKey
					&& !keyboardEventArgs.CtrlKey
					&& !keyboardEventArgs.AltKey;

					if (hasNoSpecialKeys
						&& keyboardEventArgs.Key.Length == 1)
					{
						_fsmDrawer.SelectedState.Text += keyboardEventArgs.Key;
						_caretVisible = true;
					}
					break;
			}
			await _fsmDrawer.DrawMachineAsync(_caretVisible);
		}
	}

	private async Task MoveMouseHandler(MouseEventArgs mouseEventArgs)
	{
		if (CheckJsModule(JsModule))
		{
			// Equation of Circle -> (x-a)^2 + (y-b)^2 <= r^2
			// where (a,b) are x and y coordinates of the centre of the circle respectively
			// r is radius of circle
			if (mouseEventArgs.CtrlKey && mouseEventArgs.Buttons > 0 && _fsmDrawer.SelectedState != null)
			{
				if (_canResizeState)
				{
					var coords = _fsmDrawer.SelectedState.Coordinate;
					float newRadius = (float) Math.Sqrt(
						Math.Pow(mouseEventArgs.OffsetX - coords.X, 2)
						+ Math.Pow(mouseEventArgs.OffsetY - coords.Y, 2)
					);
					_fsmDrawer.SelectedState.Radius = newRadius;
				}
			}
			else
				_fsmDrawer.MoveState(mouseEventArgs, _lastXPos, _lastYPos);

			SetLastCoords(mouseEventArgs.OffsetX, mouseEventArgs.OffsetY);
			await _fsmDrawer.DrawMachineAsync(_caretVisible);
		}
	}

	private async void DrawMachineTimer(object? obj)
	{
		if (!_stopTimer)
		{
			await _fsmDrawer.DrawMachineAsync(_caretVisible);
			_logger.LogDebug("State machine is redrawn at {Time} with caret {Visibilty}.",
			DateTimeOffset.Now, _caretVisible ? "visible" : "not visible");
		}
		_caretVisible = !_caretVisible;
		_lastDrawTimerCall = DateTime.Now;
	}

	private async Task DeselectState(FocusEventArgs focusEventArgs)
	{
		_fsmDrawer.SelectedState = null;
		_caretVisible = false;
		_stopTimer = false;

		if (_drawTimer != null)
			await _drawTimer.DisposeAsync();

		await _fsmDrawer.DrawMachineAsync(_caretVisible);
		_logger.LogInformation("Canvas isn't the focused element in the page.");
	}

	async ValueTask IAsyncDisposable.DisposeAsync()
	{
		GC.SuppressFinalize(this);
		if (JsModule != null)
			await JsModule.DisposeAsync();

		if (_drawTimer != null)
			await _drawTimer.DisposeAsync();
	}
}
