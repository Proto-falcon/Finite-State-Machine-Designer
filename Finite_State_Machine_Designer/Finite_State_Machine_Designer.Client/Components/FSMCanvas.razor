@using System.Text
@using System.Text.RegularExpressions
@using FSM
@inherits ModuleCheckBaseComponent
@rendermode InteractiveWebAssembly
@implements IAsyncDisposable
@inject IFSMDrawer _fsmDrawer
@inject ILogger<FSMCanvas> _logger

<div class="center canvas-top-buttons">
	<!--Export as:
	<a href="javascript:saveAsPNG()"
	   download>PNG</a>
	   |
	<a href="javascript:saveAsSVG()"
	   download>SVG</a>
	   |
	<a href="javascript:saveAsLaTeX()"
	   download>LaTeX</a>
	-->
	<button title="ctrl+."
		style="background-color:@(_superScriptMode ? "#a45cbd": "#ffffff");"
		@onclick="ToggleSuperScriptHandler"
	>
		aˣ
	</button>
	<button title="ctrl+,"
		style="background-color:@(_subScriptMode ? "#a45cbd": "#ffffff");"
		@onclick="ToggleSubScriptHandler"
	>
		aₓ
	</button>
</div>
<canvas
	id="FSMCanvas"
	@ref="_canvasElement"
	contenteditable="true"
	height="@Height"
	width="@Width"
	@onmousedown:preventDefault
	@onmousedown="MouseDownHandler"
	@onmouseup="MouseUpHandler"
	@onkeydown:preventDefault
	@onkeydown="KeyHandler"
	@onmousemove="MoveMouseHandler"
	@onblur="DeselectState"
>
	Your browser does not support the HTML5 &lt;canvas&gt;
	element.
</canvas>

@code {
	[Parameter]
	public int Height { get; set; } = 150;

	[Parameter]
	public int Width { get; set; } = 300;

	[Parameter]
	public bool MustRetryContext { get; set; } = false;

	private ElementReference? _canvasElement;

	private Timer? _drawTimer;
	private bool _canResizeState = false;
	private bool _subScriptMode = false;
	private bool _superScriptMode = false;
	private bool _stopTimer = true;
	private bool _caretVisible = true;
	private int _drawTimerInterval = 500;
	private DateTime _lastDrawTimerCall = DateTime.Now;
	/// <summary>
	/// Previous state of <see cref="FSMDrawer.SelectedState"/>.
	/// </summary>
	private FiniteState? _prevSelectedState;
	/// <summary>
	/// Previous state of <see cref="FSMDrawer.SelectedTransition"/>.
	/// </summary>
	private StateTransition? _prevSelectedTransition;

	/// <summary>
	/// The last co-ordinate of the pointer relative in the canvas space.
	/// </summary>
	private CanvasCoordinate _lastMousePos = new (0, 0);

	private float _defalutStateRadius = 30;
	private int _transitionSearchRadius = 10;
	private bool _canvasHasFocus = false;

	private const string _selectedStateColour = "#9999ff";
	private const string _stateColour = "#ffffff";

	/// <summary>
	/// <para>Lowercase greek symbols in unicode range: U+03b1 to U+03c9</para>
	/// <para>Uppercase greek symbols in unicode range: U+0391 to U+03a9</para>
	/// <para>Unicode for empty set (∅): U+2205</para>
	/// <para>Unicdoe for rightarrow (→): U+2192</para>
	/// <para>Unicode for leftarrow (←): U+2190</para>
	/// </summary>
	private readonly string[] _greekAlphabet = [
		"alpha",
	"beta",
	"gamma",
	"delta",
	"epsilon",
	"zeta",
	"eta",
	"theta",
	"iota",
	"kappa",
	"lambda",
	"mu",
	"nu",
	"xi",
	"omicron",
	"pi",
	"rho",
	"sigma",
	"tau",
	"upsilon",
	"phi",
	"chi",
	"psi",
	"omega"
	];

	protected async override Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			_drawTimer = _drawTimer = new Timer(DrawMachineTimer, null, 0, _drawTimerInterval);

			await SetJsModule("./Components/FSMCanvas.razor.js");

			if (CheckJsModule(JsModule))
			{
				_fsmDrawer.SetStateColours(_stateColour, _selectedStateColour);
				_fsmDrawer.FSM.TransitionSearchRadius = _transitionSearchRadius;
				_fsmDrawer.SetJsModule(JsModule);
				await JsModule.InvokeAsync<bool>("getCanvasContext", "FSMCanvas");
			}
		}
		if (CheckJsModule(JsModule) && MustRetryContext)
		{
			var isCreated = await JsModule.InvokeAsync<bool>("getCanvasContext", "FSMCanvas");

			if (isCreated)
				MustRetryContext = false;
			else
				_logger.LogError("Couldn't get 2d context");
		}

		if (_canvasElement is not null && _canvasHasFocus)
		{
			await _canvasElement.Value.FocusAsync(true);
			_canvasHasFocus = false;
		}

		if (!_stopTimer && (_fsmDrawer.SelectedState is not null || _fsmDrawer.SelectedTransition is not null)
			&& _drawTimer is not null
			&& (DateTime.Now - _lastDrawTimerCall) > TimeSpan.FromMilliseconds(_drawTimerInterval * 1.1)
		)
		{
			await _drawTimer.DisposeAsync();

			_drawTimer = new Timer(DrawMachineTimer, null, 0, _drawTimerInterval);
			_logger.LogDebug("Restarted the draw timer");
		}
	}

	private void SetLastCoords(double x, double y) => _lastMousePos = new((int)x, (int)y);

	private async Task MouseDownHandler(MouseEventArgs mouseEventArgs)
	{
		SetLastCoords(mouseEventArgs.OffsetX, mouseEventArgs.OffsetY);

		if (CheckJsModule(JsModule))
		{
			FiniteState? existingState = null;
			StateTransition? existingTransition = null;
			switch (mouseEventArgs.ShiftKey)
			{
				case false:
					existingState = _fsmDrawer.FSM.FindState(_lastMousePos);

					if (mouseEventArgs.Detail == 2)
					{
						bool exist = await DrawStateOrFinal(existingState);
						return;
					}

					_prevSelectedState = _fsmDrawer.SelectedState;
					_fsmDrawer.SelectedState = existingState;

					ToggleResizeState(_fsmDrawer.SelectedState);

					if (existingState is not null)
						_fsmDrawer.SelectedTransition = null;
					else
					{
						existingTransition = _fsmDrawer.FSM.FindTransition(_lastMousePos);
						Console.WriteLine(existingTransition);
						if (existingTransition is not null)
							_fsmDrawer.SelectedTransition = existingTransition;
						else
							_fsmDrawer.SelectedTransition = null;
					}

					break;
				case true:
					FiniteState? fromState = _fsmDrawer.FSM.FindState(_lastMousePos);

					if (fromState is null)
					{
						existingTransition = await _fsmDrawer.CreateTransitionAsync(
							_lastMousePos, _lastMousePos
						);
					}
					else
					{
						existingTransition = await _fsmDrawer.CreateTransitionAsync(
							fromState: fromState, toState: fromState
						);
					}

					_prevSelectedTransition = _fsmDrawer.SelectedTransition;
					_fsmDrawer.SelectedTransition = existingTransition;
					break;
			}

			await UpdateDrawTimer();
		}
		if (_canvasElement is not null)
			_canvasHasFocus = true;
	}

	private async Task MoveMouseHandler(MouseEventArgs mouseEventArgs)
	{
		if (CheckJsModule(JsModule))
		{
			if (mouseEventArgs.Buttons > 0)
			{
				// Equation of Circle -> (x-a)^2 + (y-b)^2 <= r^2
				// where (a,b) are x and y coordinates of the centre of the circle respectively
				// r is radius of circle
				if (_fsmDrawer.SelectedState is not null)
				{
					if (mouseEventArgs.CtrlKey && _canResizeState)
					{
						CanvasCoordinate coords = _fsmDrawer.SelectedState.Coordinate;
						float newRadius = (float) Math.Sqrt(
							Math.Pow(mouseEventArgs.OffsetX - coords.X, 2)
							+ Math.Pow(mouseEventArgs.OffsetY - coords.Y, 2)
						);
						_fsmDrawer.SelectedState.Radius = newRadius;
					}
					else if (mouseEventArgs.Buttons <= 3)
					{
						CanvasCoordinate newCoord = new(mouseEventArgs.OffsetX, mouseEventArgs.OffsetY);
						_fsmDrawer.MoveState(_fsmDrawer.SelectedState, newCoord, _lastMousePos);
						List<StateTransition> transitions = _fsmDrawer.FSM.FindTransitions(_fsmDrawer.SelectedState);
						foreach (var transition in transitions)
							if (!transition.FromState.IsDrawable)
								_fsmDrawer.MoveState(transition.FromState, newCoord, _lastMousePos);
					}
				}
				else if (_fsmDrawer.SelectedTransition is not null)
				{
					CanvasCoordinate newCoord = new((int)mouseEventArgs.OffsetX, (int)mouseEventArgs.OffsetY);
					switch (mouseEventArgs.ShiftKey)
					{
						case false:
							if (!_fsmDrawer.SelectedTransition.FromState.IsDrawable)
								_fsmDrawer.SelectedTransition.FromCoord = newCoord;
							break;
						case true:
							FiniteState? tempToState = _fsmDrawer.FSM.FindState(newCoord);
							if (tempToState is not null)
								_fsmDrawer.SelectedTransition.ToState = tempToState;
							else
							{
								FiniteState emptyState = new(newCoord, 0) { IsDrawable = false };
								_fsmDrawer.SelectedTransition.ToState = emptyState;
							}
							break;
					}
				}
			}
			SetLastCoords(mouseEventArgs.OffsetX, mouseEventArgs.OffsetY);

			await _fsmDrawer.DrawMachineAsync(_caretVisible);
		}
	}

	private void MouseUpHandler(MouseEventArgs mouseEventArgs)
	{
		SetLastCoords(mouseEventArgs.OffsetX, mouseEventArgs.OffsetY);
		FiniteState? existingState = _fsmDrawer.FSM.FindState(_lastMousePos);
		if (_fsmDrawer.SelectedTransition is not null)
		{
			StateTransition transition = _fsmDrawer.SelectedTransition;
			if (!transition.ToState.IsDrawable)
			{
				_fsmDrawer.FSM.RemoveTransition(_fsmDrawer.SelectedTransition);
				_fsmDrawer.SelectedTransition = null;
			}
		}
	}

	/// <summary>
	/// Stops the draw timer when both <see cref="FSMDrawer.SelectedState"/>
	///  and <see cref="FSMDrawer.SelectedTransition"/> are <see langword="null"/>.
	/// <para>Restarts timer when either aren't <see langword="null"/>.</para>
	/// </summary>
	private async Task UpdateDrawTimer()
	{
		if (_prevSelectedState != _fsmDrawer.SelectedState)
		{
			switch (_fsmDrawer.SelectedState)
			{
				case null:
					_stopTimer = true;
					_caretVisible = false;
					break;
				default:
					_stopTimer = false;
					_caretVisible = true;
					break;
			}
		}
		else if (_prevSelectedTransition != _fsmDrawer.SelectedTransition)
		{
			switch (_fsmDrawer.SelectedTransition)
			{
				case null:
					_stopTimer = true;
					_caretVisible = false;
					break;
				default:
					_stopTimer = false;
					_caretVisible = true;
					break;
			}
		}
		await _fsmDrawer.DrawMachineAsync(_caretVisible);
	}

	/// <summary>
	/// Creates a new state or make an existing state final
	/// </summary>
	/// <param name="existingState">A possible existing state</param>
	/// <returns>
	///  <see langword="true"/> for when the <paramref name="existingState"/> exists,
	///  otherwise <see langword="false"/>.
	/// </returns>
	private async Task<bool> DrawStateOrFinal(FiniteState? existingState)
	{
		CanvasCoordinate? createdCoords = null;
		if (existingState == null)
		{
			createdCoords = await _fsmDrawer.CreateStateAsync(
				_lastMousePos,
				_defalutStateRadius
			);
			await UpdateDrawTimer();
			_stopTimer = !(createdCoords is not null);
			if (_stopTimer)
			{
				_logger.LogError("State to be created at {Coordinate} failed to be created", createdCoords);
				return false;
			}
			return true;
		}
		else if (existingState == _fsmDrawer.SelectedState)
		{
			_fsmDrawer.SelectedState.IsFinalState = !_fsmDrawer.SelectedState.IsFinalState;
			await _fsmDrawer.DrawMachineAsync(true);
			return true;
		}
		return false;
	}

	/// <summary>
	/// Makes the <paramref name="state"/> resizable
	/// </summary>
	/// <param name="state">A finite state</param>
	private void ToggleResizeState(FiniteState? state)
	{
		if (state is null)
			return;

		var coords = state.Coordinate;
		float radius = (float)Math.Sqrt(
			Math.Pow(_lastMousePos.X - coords.X, 2)
			+ Math.Pow(_lastMousePos.Y - coords.Y, 2)
		);

		_logger.LogDebug("Radius difference: {Difference}", Math.Abs(radius - state.Radius));
		if (Math.Abs(radius - state.Radius) <= 10)
			_canResizeState = true;
		else
			_canResizeState = false;
	}

	private async Task KeyHandler(KeyboardEventArgs keyboardEventArgs)
	{
		if (CheckJsModule(JsModule))
		{
			if (_fsmDrawer.SelectedState is not null)
				StateKeyHandler(keyboardEventArgs, _fsmDrawer.SelectedState);
			else if (_fsmDrawer.SelectedTransition is not null)
				TransitionKeyHandler(keyboardEventArgs, _fsmDrawer.SelectedTransition);
			await _fsmDrawer.DrawMachineAsync(_caretVisible);
		}
	}

	private void StateKeyHandler(KeyboardEventArgs keyboardEventArgs, FiniteState state)
	{
		if (CheckJsModule(JsModule))
		{
			switch (keyboardEventArgs.Key.ToLower())
			{
				case "backspace":
					if (state.Text.Length > 0)
					{
						var text = state.Text;
						state.Text = text.Substring(0, text.Length - 1);
						var coordinate = state.Coordinate;

						_caretVisible = true;
					}
					break;
				case "delete":
					if (_fsmDrawer.FSM.RemoveState(state))
					{
						List<StateTransition> connectedTransitions = _fsmDrawer.FSM.FindTransitions(state);
						foreach (StateTransition transition in connectedTransitions)
							_fsmDrawer.FSM.Transitions.Remove(transition);
					}
					break;
				case "return":
				case "enter":
				case "↵":
					state.Text += '\n';
					_caretVisible = true;
					break;
				case "spacebar":
				case " ":
					state.Text += ' ';
					_caretVisible = true;
					break;
				default:
					if (UpdateTextStyle(keyboardEventArgs))
						break;

					if (keyboardEventArgs.Key.Length == 1)
					{
						AddStateText(state, keyboardEventArgs.Key);
					}
					break;
			}
		}
	}

	private void TransitionKeyHandler(KeyboardEventArgs keyboardEventArgs, StateTransition transition)
	{
		if (CheckJsModule(JsModule))
		{
			switch (keyboardEventArgs.Key.ToLower())
			{
				case "delete":
					_fsmDrawer.FSM.RemoveTransition(transition);
					break;
				default:
					break;
			}
		}
	}

	private bool UpdateTextStyle(KeyboardEventArgs keyboardEventArgs)
	{
		bool updatedStyle = false;
		if (keyboardEventArgs.CtrlKey)
		{
			if (keyboardEventArgs.Key == ".")
			{
				_subScriptMode = !_subScriptMode;
				_superScriptMode = false;
				updatedStyle = true;
			}
			else if (keyboardEventArgs.Key == ",")
			{
				_superScriptMode = !_superScriptMode;
				_subScriptMode = false;
				updatedStyle = true;
			}
		}
		return updatedStyle;
	}

	private void ToggleSuperScriptHandler(MouseEventArgs mouseEventArgs)
	{
		_subScriptMode = false;
		_superScriptMode = !_superScriptMode;
	}

	private void ToggleSubScriptHandler(MouseEventArgs mouseEventArgs)
	{
		_superScriptMode = false;
		_subScriptMode = !_subScriptMode;
	}

	private void AddStateText(FiniteState finiteState, string newText)
	{
		// For superscript numbers ⁰ and ⁷, numbers 1-3 are in U+00B9, U+00B2, U+00B3 respectively
		// However subscript numbers are within U+208x where 0 < x < 9
		// Instead of typing '_0' to get '₀', just press 'ctrl ,' for superscript mode and 'ctrl .' for subscript mode
		int utfSubSuperRange = 0x2080;
		if (_superScriptMode)
			utfSubSuperRange = 0x2070;
		if (_superScriptMode || _subScriptMode)
		{
			char[] characters = newText.ToCharArray();
			for (int i = 0; i < characters.Length; i++)
			{
				if (char.IsDigit(characters[i]))
				{
					int newUtfCode = 0;
					int keyNum = int.Parse(newText[i].ToString());
					if (_superScriptMode && (characters[i] == '2' || characters[i] == '3'))
						newUtfCode = 0x00B0 + keyNum;
					else if (_superScriptMode && characters[i] == '1')
						newUtfCode = 0x00B9;
					else
						newUtfCode = utfSubSuperRange + keyNum;
					characters[i] = char.ConvertFromUtf32(newUtfCode)[0];
				}
			}
			newText = string.Concat(characters);
		}

		newText = finiteState.Text + newText;
		for (int i = 0; i < _greekAlphabet.Length; i++)
		{
			Regex greekRegex = new(@$"\\{_greekAlphabet[i]}", RegexOptions.IgnoreCase);
			int offsetAfterRho = Convert.ToInt32(i > 16);
			newText = newText.Replace(@$"\{_greekAlphabet[i]}", char.ConvertFromUtf32(0x003b1 + i + offsetAfterRho));
			newText = greekRegex.Replace(newText, char.ConvertFromUtf32(0x0391 + i + offsetAfterRho));
		}

		/*
		* Unicode for empty set (∅): U+2205
		* Unicdoe for rightarrow (→): U+2192
		* Unicode for leftarrow (←): U+2190
		*/
		newText = newText.Replace(@"\emptyset", char.ConvertFromUtf32(0x2205));
		newText = newText.Replace(@"\rightarrow", char.ConvertFromUtf32(0x2192));
		newText = newText.Replace(@"\leftarrow", char.ConvertFromUtf32(0x2190));

		finiteState.Text = newText;
		_caretVisible = true;
	}

	private async void DrawMachineTimer(object? obj)
	{
		if (!_stopTimer && _fsmDrawer.SelectedState is not null)
		{
			await _fsmDrawer.DrawMachineAsync(_caretVisible);
			_logger.LogDebug("State machine is redrawn at {Time} with caret {Visibilty}.",
			DateTimeOffset.Now, _caretVisible ? "visible" : "not visible");
		}
		_caretVisible = !_caretVisible;
		_lastDrawTimerCall = DateTime.Now;
	}

	private async Task DeselectState(FocusEventArgs focusEventArgs)
	{
		_fsmDrawer.SelectedState = null;
		_caretVisible = false;
		_stopTimer = false;

		if (_drawTimer is not null)
			await _drawTimer.DisposeAsync();

		await _fsmDrawer.DrawMachineAsync(_caretVisible);
		_logger.LogInformation("Canvas isn't the focused element in the page.");
	}

	async ValueTask IAsyncDisposable.DisposeAsync()
	{
		GC.SuppressFinalize(this);
		if (JsModule is not null)
			await JsModule.DisposeAsync();

		if (_drawTimer is not null)
			await _drawTimer.DisposeAsync();
	}
}
